0620
1. 反馈
  -> 分组( 正则 )
    -> 分组的编号
      从左往右数 左圆括号, 依次从 1 开始编号
    -> 分组的使用问题
      -> 提取解析
        例如: 邮箱的正则:  [\d\w-\_]+@[\d\w-\_]+(\.[\d\w-\_]+)+
        在使用 var str = 'itcast@itcast.cn, itheima@itcast.cn, 1234567@qq.com';
          r.exec( str )
        如果要对解析出来的数据进行分析, 例如将用户名与主机名分离, 常规做法是将 结果 用 @ split
        但是正则允许一步到位. 使用分组即可
          var r = /([\d\w-\_]+)@([\d\w-\_]+(?:\.[\d\w-\_]+)+)/g;
        全局模式就是重复执行
          '123a456a789a'.replace( /a/, 'A' )   => '123A456a789a'
          '123a456a789a'.replace( /a/g, 'A' )  => '123A456A789A'
      -> 替换保留原始数据
        '2017-12-28'.replace( /(\d+)-(\d+)-(\d+)/, '$1年$2月$3日' )
        案例: 
          在网络上利用代码获得某一个页面中的所有图片 url, 利用 正则将图片摘取出来
          生成相应的图片链接. 例如 
            var imgs = [
              'http://1234566.com/1234567.jpg'
            ];
          生成
            <a href="http://1234566.com/1234567.jpg"><img src="http://1234566.com/1234567.jpg"></a>
          
    -> 不捕获分组
      (?: )
  -> 
    var arr = [];
     for (var i = 0; i < 10; i++) {
        arr.push(function () {
            return console.log(i);
        });
    };

    arr[0]();
    arr[1]();
    arr[2]();
  -> 
    for(var i=0;i<5;++i){
        setTimeout(function (){
            console.log(i+ '');
        },100);
    }
  -> 词法作用域( 全局, 函数 )
    var arr = [];
     for (var i = 0; i < 10; i++) {
        arr.push(function () {
            return console.log(i);
        });
    };

    for ( var i = 0; i < 10; i++ ) {
      arr[ i ]();
    }


2. canvas
  -> 什么是 canvas
      翻译: 画布, 帆布, 油布
      其在 HTML 中就是一个用于展示图片用的东西( 标签 )
      这个标签不能绘图, 只能展示. 利用这个标签来获得绘图上下文.
  -> 绘图上下文
      就是绘图工具
      由于绘图工具与画布有直接关系, 因此不同的画布需要获得不同的绘图上下文
      一个 canvas 对应一个工具, 工具只能给这个 canvas 绘图, 如果需要给另一个绘图就需要用另一个 canvas 获得绘图工具
  -> 如何使用 canvas
    -> 语法
      <canvas></canvas>
    -> 说明:
      1> canvas 的默认宽高: 300, 150
      2> 宽高的意义: 是指 canvas 有对应的几个像素点
          宽 300, 表示有 300 个像素
          高 150, 表示有 150 个像素
          默认 canvas 是一个 300 * 150 像素的点阵屏幕
      3> 图形分为点阵图和矢量图
          点阵图就是利用像素点一个一个的连接在一起形成图形.
          矢量图是利用数学函数描述图形的轨迹, 在图片放大的时候, 轨迹重新绘制是看不到点阵的.
          使用 canvas 画出来的都是点阵图
      4> 设置 canvas 的宽高, 必须使用属性 width 和 height, 不能使用样式设置
          使用属性来设置宽高就是在设置横竖多少像素
          但是如果是使用 css 来设置宽高, 是将 canvas 画布进行拉伸处理.
            也就是说 css 设置: width: 600px; height: 300px;
            表示画布的宽高为 600, 300, 但是依旧只有 300, 150 像素.
      5> 如何获得绘图工具
          canvas.getContext( '2d' ) 
          获得绘制 2d 图像的绘图 api( 绘图工具 ), 我们将其称为绘图上下文.
          canvas.getContext( 'webgl' )
          获得绘制 3d 的图像( three.js ) 
  -> 课程定位
    -> canvas 市场上的应用
      -> 播放器( youtube )  可以参考开源项目 FFmpeg
      -> VR( AR )           
      -> 数据可视化         d3, echarts
      -> 广告
      -> 在线图形编辑器( 在线 photoshop )
      -> 游戏
    -> 课程的定位: 数据可视化

  
3. 计算机中的坐标系
  -> 在 计算机中, 坐标轴与中学时代略有不同, x 轴水平向右( 和中学一样 ), y 轴竖直向下( 与中学相反 ).
  -> 在绘制点的时候, 需要注意的是计算坐标( 任务 )

4. 怎么绘制
  -> 在计算机中绘制图片就好比你指挥别人绘图一样, 需要告知从哪里, 绘制到哪里, 绘制什么图形
  -> 在得到绘图上下文以后( 绘图工具 )
    绘图上下文会提供各种绘图使用的工具, 我们只需要使用工具绘图即可
    1> 落笔使用 context.moveTo( x, y )
    2> 绘制直线使用 context.lineTo( x, y )
    3> 在 canvas 中绘图与真实绘图环境一样, 当你落笔后绘制到什么位置, 就表示笔停到那个位置, 
        如果没有再次落笔, 下一次绘制就接着当前笔所在的位置开始绘制.
    4> 在计算机中如果要绘制连线的图, 使用 context.stroke(), 如果需要填充, 使用 context.fill() 
  -> 绘制矩形案例
    约定绘制一个 宽高为 300*200 的矩形

5. 中午补充
    -> 数据在内存中只有数字( charAt, charCodeAt )
      ASCII 码( 7 个二进制位表示 ) 0 ~ 127
        前 32 个 属于控制字符 ( 0 ~ 31 )
        从 第 32 个开始 属于可见字符, 第 32 个就是空
        数字字符从 48 开始, 0, 1, 2, 等这些字符分别由 48, 49, 50, 51, ..., 57 这几个数字表示
        小写英文字母, 从 97 开始
        大写英文字母, 从 65 开始
      IBM 通用机 将 ASCII 码 扩展到 8 个二进制位. 
      国际的通用, 发明双字节字符( 使用两个字节表示一个字符 ), 最多可以表示 65535 个.
      引入了 unicode 编码, 也是使用两个字节, 所有的字符编码在设计的时候, 前 128 个都是和 ascii 码兼容的.
      引入 UTF 系列( utf-7, utf-8, utf-16, utf-32 )
        utf-8 系列: 前 128 个都是一个字节, 简体中文使用 3 个字节. 
        亚洲地区将 中文, 韩文, 日文字符集常常称为 CJK 字符串
    -> 类型判断的问题
      -> instanceof 运算符
        语法: 
          对象 instanceof 函数
        如果 函数.prototype 这个对象在 对象的原型链上, 那么就返回 true, 否则返回 false
      -> ES5 引入了对数组的判断 Array.isArray( ... )
      -> toString.call

6. 绘制

7. canvas 的绘图原理
  现象: 在 canvas 中绘制直线很虚

8. canvas 绘制线的连接部分

9. 线的闭合问题
  在 convas 中使用 closePath 来实现闭合路径
  他会将你本次绘制的起点与重点连接起来

10. 绘制多样式的图形
  现在只能绘制描线或填充的图
  凡是在绘制中, 用于描述绘制的颜色, 尺寸, 样式, 是否为描边, 是否为填充特征都是指样式
  凡是要更改样式就需要调用一次 context.beginPath 方法.

  比喻:
    每次打开 canvas 的时候, 要绘图就需要创建一个 path
    而这一个 path 只包含一个样式的图形, 如果想要得到多样式的图形就需要多个 path
    将这些 path 重叠起来就是一个完整的图形.

  注意:
    每次 beginPath 的时候, 前面所有设置的样式都会被继承

11. 在绘制图形的时候, 有两个主要的方法
  -> stroke
  -> fill
  这两个方法一个用于描线, 一个用于填充, 如果要更新颜色等样式, 
  就需要单独设置是要改变描线的颜色还是填充的颜色. 使用语法
    xxxStyle
  如果改变描线的颜色使用 strokeStyle
  如果要改变填充的颜色使用 fillStyle

  而其取值与 css 取值一样, 可以是名字, 可以是 #+数字, 可以是 rgb 或 rgba


  练习, 绘制渐变色块( 作业 )


12. 非零环绕原则
  所谓非零环绕原则是指图形在封闭曲线的情况下是否要填充的准则
  
  由于绘图的时候在复杂图形中填充是一个比较麻烦的问题, 
  因此引入非零环绕原则来判断一个区域是否要填充. 
  那么在一个区域中如果是没有用线分离的区域, 那么他们是一个联通区域.
  在考虑填充的时候, 只要确保一个联通区域中的某一个点是否要填充 
  就可以确定这一整个区域是否要填充. 因此判断原则就转而编程判断点是否要填充.

  非零环绕原则
  1> 首先在不确定是否要填充的区域, 随意的找一个点( 找的时候尽量简单 ).
  2> 由这个点向图形的外面随意的作一条射线( 尽可能简单 )
  3> 由这个点作为圆心, 判断穿过这条射线的所有线, 以及其方向.
    将所有的顺时针方向记为 +1, 将所有的逆时针记为 -1
  4> 将所有的数字求和, 如果结果为 0, 则不填充, 如果非零 则填充.


13. 绘制虚线
  只需要设置 lineDashe 即可. 
  调用 setLineDash 和 getLineDash 可以设置与获得当前虚线的样式.
  虚线的样式使用 [  ] 来描述, 里面的数字表示实线部分与空白部分的长度.
  例如: [ 10, 5 ], 如果数组是奇数, [ 10, 5, 7 ], 那么就循环处理.
  所以一般表示等宽虚线使用 [ 5 ]














